# coding: utf-8

import xml.etree.ElementTree as ET
import numpy as np
import os

"""
The structure of "vasprun.xml" file generated by VASP:
   |-- generator: program, version, ..., data, time
   |-- incar: the parameters defined in INCAR
   |-- structure: the primitive cell defined in POSCAR
   |-- varry:
   |-- kpoints: the kpoint list
   |-- parameters: the parameters defined for the VASP job
   |-- atominfo: the atomic infomation
   |-- structure: the initial structure
   |-- calculation: the calculation results (scstep, structure, varray, energy,
       time, eigenvalue, separator, dos, projected)
   |-- structure
"""

class VaspXml(object):
    """
    VaspXml object for reading and analyzing the "vasprun.xml" file generated
    by VASP.
    """
    def __init__(self, filename = "vasprun.xml"):
        """
        Create a VaspXml object, representing the "vasprun.xml" file.
        Args:
            filename (str): the name/path of the "vasprun.xml" file in xml
                            format. Default to "vasprun.xml".
        Example:
            >>> myxml = VaspXml("vasprun.xml")
        """
        if not os.path.isfile(filename):
            raise ValueError (
                    "The provided file '{}' doesn't exist.".format(filename)
                    )

        self.filename = filename
        # The root node of the xml-structured file
        self.root = ET.parse(self.filename).getroot()

    def get_parameter(self, param):
        """
        Get the parameter param from the "parameters" node of the xml file.
        Args:
            param (str): the parameter name of the VASP calculation.
        Returns:
            The type of the returned value depends on the param.
            It might be the type (int, string, logical) specified in its
            attribute, or string if not specified.
        example:
            >>> myxml = VaspXml("vasprun.xml")
            >>> myxml.get_parameter('IALGO')
            12
        """
        node = self.root.find("./parameters//i[@name='{}']".format(param))
        if 'type' in node.attrib:
            if node.attrib['type'] == 'int':
                return int(node.text)
            elif node.attrib['type'] == 'string':
                return node.text.strip()
            elif node.attrib['type'] == 'logical':
                if node.text.strip() == 'F':
                    return False
                else:
                    return True
        else:
            return node.text.strip()

    def get_species(self):
        """
        Get the atom names in the structure.
        Returns:
            atoms (list): containing the symbols of the atoms.
        example:
            >>> myxml = VaspXml("vasprun.xml")
            >>> myxml.get_atoms()
            ['Co', 'S', 'S']
        """
        atoms = []
        rcs = self.root.findall(".//array[@name='atoms']/set/rc")
        for rc in rcs:
            atom = rc.find('./c').text
            atoms.append(atom.strip())
        return atoms

    def get_nkpts(self):
        """
        Return the number of kpoints of the VaspXml project.
        The eigenvalues of all these kpoints have been calculated and shown in
        the "calculation" subsection.
        Returns:
            int: the number of kpoints.
        """
        kpt_list = self.root.findall("./kpoints/varray[@name='kpointlist']/v")
        return len(kpt_list)

    def get_efermi(self):
        """
        Return the fermi energy of the VaspXml object.
        Returns:
            efermi (float): fermi energy in eV.
        """
        txt = self.root.find('calculation').find('dos').find("./i[@name = 'efermi']").text
        return float(txt.strip())

    def get_reclattice(self):
        """
        Return the three reciprocal lattice vectors of the structure,
        in the order of a', b', and c'.
        Returns:
            reclattice (np.array): 3 * 3 numpy array representing the reciprocal
            lattice vectors
                                np.array([a', b', c'])
        """
        reclattice = np.empty((0, 3), float)
        vectors = self.root.findall(
                "./structure[@name='finalpos']//varray[@name='rec_basis']/v"
                )
        for vector in vectors:
            vector = np.fromstring(vector.text, dtype = float, sep = ' ')
            reclattice = np.append(reclattice, np.array([vector]), axis = 0)
        return reclattice

    def get_kpoints(self):
        """
        Get the fractional coordinates of all the kpoints.
        Returns:
            kpoints (np.ndarray)
        """
        kpoints = []
        kpt_list = self.root.findall("./kpoints/varray[@name='kpointlist']/v")
        for kpt in kpt_list[:]:
            kpt_current = np.fromstring(kpt.text, dtype = float, sep = ' ')
            kpoints.append(kpt_current)

        kpoints = np.array(kpoints)

        return kpoints

    def get_kdistance(self):
        """
        Get the distance of the kpoints from the 1st kpoint along the kpoints path.
        Starting from 0. It is used when plotting the band structure.
        Returns:
            distance_cart (list[float]): the distance of the kpoints from the
            1st kpoint along the kpoints path.
        example:
            >>> myxml = VaspXml("vasprun.xml")
            >>> myxml.get_kdistance()
            [0, 0.02, 0.04, ...]
        """
        reclattice = self.get_reclattice()

        distance_cart = np.zeros((1,), float)
        kpt_list = self.root.findall("./kpoints/varray[@name='kpointlist']/v")
        #The previous kpoint direct coordination
        kpt_prev = np.fromstring(kpt_list[0].text, dtype = float, sep = ' ')
        for i in range(1, len(kpt_list)):
            #The current kpoint direct coordination
            kpt_current = np.fromstring(kpt_list[i].text,
                                        dtype = float,
                                        sep = ' ')
            neighboring_distance = np.linalg.norm(
                                np.dot(kpt_current - kpt_prev, reclattice)
                                )
            distance_current = distance_cart[i - 1] + neighboring_distance
            distance_cart = np.append(distance_cart, distance_current)
            kpt_prev = kpt_current

        return distance_cart

    def get_high_symmetry_kpoints(self):
        """
        Get the kdistance values for the high symmetry kpoints defind by the user.
        Returns:
            list(float)
        """
        res = []
        reclattice = self.get_reclattice()
        distance = None
        for v in self.root.findall("./kpoints/generation[@param='listgenerated']/v"):
            if distance == None:
                kpt_prev = np.fromstring(v.text, dtype = float, sep = ' ')
                distance = 0
            else:
                kpt_current = np.fromstring(v.text, dtype = float, sep = ' ')
                distance += np.linalg.norm(
                                    np.dot(kpt_current - kpt_prev, reclattice)
                                    )
                kpt_prev = kpt_current
                res.append(distance)
        return res

    def get_orbitals(self):
        """
        Get the name of the resolved electron orbits.
        Returns:
            orbitals (list[str]): raise ValueError if there is no resolved orbitals,
                    else return a list of strings.
        Example:
            >>> myxml = VaspXml("vasprun.xml")
            >>> myxml.get_orbitals()
            ['s', 'py', 'pz', 'px', 'dxy', 'dyz', 'dz2', 'dxz', 'x2-y2']
        """
        orbitals = []
        if not self.root.findall(".//dos/partial"):
            raise ValueError("No resolved orbitals found in this xml file.")
        fields = self.root.findall(".//partial/array/field")
        for field in fields[1:]:
            orbital = field.text.strip()
            orbitals.append(orbital)
        return orbitals

    def get_total_dos(self):
        """
        Return the total density of states of the VaspXml object. The density of spin down component
        has non-positive values.
        Returns:
            (np.array): n * 2 numpy array (n = NEDOS if ISPIN = 1,
                        else n = 2* NEDOS)
                1st column: energy (eV)
                2nd column: DOS (states/eV)
                (3rd column of total_dos: accumulated dos)
        """
        efermi = self.get_efermi()
        total_dos = np.empty((0,3), float)
        data_set = self.root.findall('calculation/dos/total/array/set//r')

        for data_point in data_set:
            arr = np.fromstring(data_point.text, dtype = float, sep = ' ')\
                                - np.array([efermi, 0, 0])
            total_dos = np.append(total_dos, np.array([arr]), axis = 0)

        nedos = self.get_parameter('NEDOS')
        if 2 * nedos == total_dos.shape[0]:
            total_dos[nedos : 2* nedos, 1:3] = -total_dos[nedos : 2* nedos, 1:3]
            
        return total_dos[:, 0:2]

    def get_dos_atom(self, atom_id, orbit):
        """
        Get the orbital resolved density of states contributed from
        the specific orbit of a specific atom.
        Args:
            atom_id (int): the index of the atom, starting from 1
            orbit (str): the orbit name, e.g., 's', 'py'
        Returns:
            pdos (np.array with a size of NEDOS * 2 if ISPIN = 1
                else 2*NEDOS * 2)
        """
        efermi = self.get_efermi()
        orbit_id = self.get_orbitals().index(orbit) # The index of the orbit
        atom_set = self.root.find(".//partial/array/set/set[{}]".format(atom_id))
        pdos = np.empty((0, 2), float) #initialize the dos

        for r in atom_set.findall(".//r"):
            energy = float(r.text.split()[0]) - efermi
            density = float(r.text.split()[orbit_id + 1])
            pdos = np.append(pdos, [[energy, density]], axis = 0)

        nedos = self.get_parameter('NEDOS')
        if 2 * nedos == pdos.shape[0]:
            pdos[nedos : 2 * nedos, 1] = -pdos[nedos : 2 * nedos, 1]

        return pdos

    def get_dos_element(self, element, orbit):
        """
        Get the orbital resolved density of states contributed from
        the orbit of the element. The density of spin down component
        has non-positive values.
        Args:
            element (str): the symbol of the elemnt, e.g., 'Ag', 'Cu'
            orbit (str): the orbit name, e.g., 's', 'py'
        Returns:
            pdos (np.array with a size of NEDOS * 2 if ISPIN = 1 else 2*NEDOS * 2)
                1st column: energy (eV)
                2nd column: dos (#/eV)
        """
        atoms = self.get_species()
        # Get the index of the atoms that match the element, starting from 1
        atoms_id = [i + 1 for i in range(len(atoms)) if atoms[i] == element]
        if len(atoms_id) == 0:
            raise ValueError("No {} element exists.".format(element))
        rdos = self.get_dos_atom(atoms_id[0], orbit)
        for atom_id in atoms_id[1:]:
            rdos[:, 1] += self.get_dos_atom(atom_id, orbit)[:, 1]
        return rdos

    def get_total_dos_element(self, element):
        """
        Get the total dos contributed from one element. The density of spin down component
        has non-positive values.
        Args:
            element (str): the symbol of the element, e.g., 'Ag', 'Au'
        Returns:
            pdos (np.array NEDOS * 2 if ISPIN = 1 else 2*NEDOS * 2):
                1st column: energy (eV)
                2nd column: dos (#/eV)
        """
        # Assert partial tag exists in the file
        if not self.root.findall(".//dos/partial"):
            raise ValueError("No resolved orbitals found in this xml file.")

        atoms = self.get_species()
        efermi = self.get_efermi()
        atoms_id = [i + 1 for i in range(len(atoms)) if atoms[i] == element]

        # The first atom
        pdos = np.empty((0, 2), float)
        for r in self.root.findall(".//partial/array/set/set[{}]//r".format(atoms_id[0])):
            r_arr = np.fromstring(r.text, float, sep = ' ')
            pdos = np.append(pdos, [[r_arr[0] - efermi, sum(r_arr[1:])]], axis = 0)
        # The other atoms
        for i in atoms_id[1:]:
            for j, r in enumerate(self.root.findall(
                        ".//partial/array/set/set[{}]//r".format(i))
                        ):
                r_dos = sum(np.fromstring(r.text, float, sep = ' ')[1:])
                pdos[j, 1] += r_dos

        nedos = self.get_parameter('NEDOS')
        if 2 * nedos == pdos.shape[0]:
            pdos[nedos : 2 * nedos, 1] = -pdos[nedos : 2 * nedos, 1]
            
        return pdos

    def get_electronic_band(self):
        """
        Return the eigenvalues of all the kpoints.
        Returns:
            band (np.array):
                size: n*(1+nbands) (n = nkpts if ISPIN = 1, else n = 2* nkpts)
                1st column: the position of the kpoint along the kpoints path,
                            starting from 0.0
                i-th column (i > 1): the energy of the eigenstate at the kpoint
        """
        nbands = self.get_parameter('NBANDS')
        kdistance = self.get_kdistance()
        band = np.empty((0, nbands + 1), float)
        efermi = self.get_efermi()

        # Read spin component 1
        eigen_set = self.root.find('./calculation/eigenvalues/array/set/set[1]')
        for i, kpoint in enumerate(eigen_set.findall("./set")):
            band_k = np.array([kdistance[i]])
            for r in kpoint.findall('./r'):
                value = r.text.split()[0]
                band_k = np.append(band_k, float(value) - efermi)
            band = np.append(band, np.array([band_k]), axis = 0)

        # Read spin componenet 2
        if self.get_parameter('ISPIN') == 2:
            eigen_set = self.root.find(
                        './calculation/eigenvalues/array/set/set[2]'
                        )
            for i, kpoint in enumerate(eigen_set.findall("./set")):
                band_k = np.array([kdistance[i]])
                for r in kpoint.findall('./r'):
                    value = r.text.split()[0]
                    band_k = np.append(band_k, float(value) - efermi)
                band = np.append(band, np.array([band_k]), axis = 0)
        return band

    def get_electronic_band_element_orbit(self, element, orbit):
        """
        Get the ocuupancy of a specific orbit of an element throughout the bands.
        Args:
            element (str): the symbol of the elemnt, e.g., 'Ag', 'Cu'
            orbit (str): the orbit name, e.g., 's', 'py'
        Returns:
            p (np.array with a size of (nkpts * NBANDS) * 3 if ISPIN = 1
            else (2 * nkpts * NBANDS) * 3
                1st column: the position of the kpoint along the kpoints path,
                            starting from 0.0
                2nd column: the energy of the eigenstate (eV)
                3rd column: occupancy (0 ~ 1)
        """
        atoms = self.get_species()
        if element not in atoms:
            raise ValueError("No {} element exists.".format(element))

        nkpts = self.get_nkpts() # no. of kpoints
        efermi = self.get_efermi() # fermi energy
        electronic_band = self.get_electronic_band()

        nbands = self.get_parameter('NBANDS')
        atoms_id = [i + 1 for i in range(len(atoms)) if atoms[i] == element]

        orbit_id = self.get_orbitals().index(orbit) # The index of the orbit
        band = np.empty((0, 3), float) #initialize the result

        # Read spin component 1
        spin1 = self.root.find('./calculation/projected/array/set/set')
        for band_idx in range(nbands):
            for k_idx in range(nkpts):
                set = spin1.find('./set[{}]/set[{}]'.format(k_idx + 1, band_idx + 1))
                occupancy = 0
                for atom in atoms_id:
                    occupancy += float(
                        set.find('./r[{}]'.format(atom)).text.split()[orbit_id]
                        )
                kx = electronic_band[k_idx][0]
                energy = electronic_band[k_idx][band_idx + 1]
                band = np.append(band, np.array([[kx, energy, occupancy]]),
                                axis = 0)

        # Read spin componenet 2
        if self.get_parameter('ISPIN') == 2:
            spin2 = self.root.find('./calculation/projected/array/set/set[2]')
            for band_idx in range(nbands):
                for k_idx in range(nkpts):
                    set = spin2.find(
                        './set[{}]/set[{}]'.format(k_idx + 1, band_idx + 1)
                        )
                    occupancy = 0
                    for atom in atoms_id:
                        occupancy += float(
                        set.find('./r[{}]'.format(atom)).text.split()[orbit_id]
                        )
                    kx = electronic_band[k_idx][0]
                    energy = electronic_band[nkpts + k_idx][band_idx + 1]
                    band = np.append(band, np.array([[kx, energy, occupancy]]),
                                    axis = 0)
        return band

    def get_electronic_band_element(self, element):
        """
        Get the ocuupancy of a specific orbit of an element throughout the bands.
        Args:
            element (str): the symbol of the elemnt, e.g., 'Ag', 'Cu'
            orbit (str): the orbit name, e.g., 's', 'py'
        Returns:
            p (np.array with a size of (nkpts * NBANDS) * 3 if ISPIN = 1
            else (2 * nkpts * NBANDS) * 3
                1st column: the position of the kpoint along the kpoints path,
                            starting from 0.0
                2nd column: the energy of the eigenstate (eV)
                3rd column: occupancy (0 ~ 1)
        """
        atoms = self.get_species()
        if element not in atoms:
            raise ValueError("The element {} does not exist.".format(element))

        nkpts = self.get_nkpts() # no. of kpoints
        efermi = self.get_efermi() # fermi energy
        electronic_band = self.get_electronic_band()

        nbands = self.get_parameter('NBANDS')
        atoms_id = [i + 1 for i in range(len(atoms)) if atoms[i] == element]

        band = np.empty((0, 3), float) #initialize the result

        # Read spin component 1
        spin1 = self.root.find('./calculation/projected/array/set/set')
        for band_idx in range(nbands):
            for k_idx in range(nkpts):
                set = spin1.find(
                        './set[{}]/set[{}]'.format(k_idx + 1, band_idx + 1)
                        )
                occupancy = 0
                for atom in atoms_id:
                    # contribute from one atom
                    temp = sum(np.fromstring(set.find('./r[{}]'.format(atom)).text,
                                            sep = ' '))
                    occupancy += temp
                kx = electronic_band[k_idx][0]
                energy = electronic_band[k_idx][band_idx + 1]
                band = np.append(band, [[kx, energy, occupancy]], axis = 0)

        # Read spin componenet 2
        if self.get_parameter('ISPIN') == 2:
            spin2 = self.root.find('./calculation/projected/array/set/set[2]')
            for band_idx in range(nbands):
                for k_idx in range(nkpts):
                    occupancy = 0
                    set = spin2.find(
                            './set[{}]/set[{}]'.format(k_idx + 1, band_idx + 1)
                            )                    
                    for atom in atoms_id:
                        # contribute from one atom
                        temp = sum(np.fromstring(set.find('./r[{}]'.format(atom)).text,
                                                sep = ' '))
                        occupancy += temp
                    kx = electronic_band[k_idx][0]
                    energy = electronic_band[nkpts + k_idx][band_idx + 1]
                    band = np.append(band, [[kx, energy, occupancy]], axis = 0)
        return band
